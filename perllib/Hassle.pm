#!/usr/bin/perl
#
# Hassle.pm:
# Common code for hassleme.
#
# Copyright (c) 2005 Chris Lightfoot. All rights reserved.
# Email: chris@ex-parrot.com; WWW: http://www.ex-parrot.com/~chris/
#

package Hassle;

use DBI;
use DBD::Pg;
use Digest::SHA qw(sha1_hex);
use IO::Pipe;
use MIME::QuotedPrint;
use mySociety::Email;
use mySociety::HandleMail;
use mySociety::EmailUtil;
use POSIX qw();

use mySociety::Config;

BEGIN {
    use Exporter ();
    @Hassle::ISA = qw(Exporter);
    @Hassle::EXPORT = qw(&dbh &secret &sendmail &token &check_token &is_valid_email &active_hassles &delete_recipient &verp_envelope_sender &get_bounced_address);
}
#our @EXPORT_OK;

sub dbh () {
    our $dbh;
    if (!$dbh) {
        $dbh ||= DBI->connect(
                        "dbi:Pg:dbname=" . mySociety::Config::get('HM_DB_NAME')
                        . ";host=" . mySociety::Config::get('HM_DB_HOST')
                        . ";port=" . mySociety::Config::get('HM_DB_PORT')
                        . ";sslmode=allow",
                        mySociety::Config::get('HM_DB_USER'),
                        mySociety::Config::get('HM_DB_PASS'),
                        {
                            AutoCommit => 0,
                            PrintError => 0,
                            RaiseError => 1,
                            PrintWarn => 0
                        });
        my $s = $dbh->selectrow_array('select secret from secret');
        if (!defined($s)) {
            $dbh->{RaiseError} = 0;
            $dbh->do('insert into secret (secret) values (?)', {},
                        sprintf('%08x%08x', int(rand(0xffffffff)),
                                            int(rand(0xffffffff))));
            $dbh->commit();
            $dbh->{RaiseError} = 1;
        }
    }
    return $dbh;
}

sub secret () {
    return scalar(dbh()->selectrow_array('select secret from secret'));
}

=item get_bounced_address ADDRESS

Get the bounced address from a VERP address created with verp_envelope_sender

=cut
sub get_bounced_address($){
    my ($address) = @_;
    my $prefix =  mySociety::Config::get('EMAIL_PREFIX');
    my $domain =  mySociety::Config::get('EMAIL_DOMAIN');
    my $bounced_address =  mySociety::HandleMail::get_bounced_address($address, $prefix, $domain);
    return $bounced_address;
}

=item verp_envelope_sender RECIPIENT

Construct a VERP envelope sender for an email to RECIPIENT

=cut
sub verp_envelope_sender($){
    my ($recipient) = @_;
    # strip whitespace
    $recipient =~ s/^\s+//;
    $recipient =~ s/\s+$//;
    my $prefix =  mySociety::Config::get('EMAIL_PREFIX');
    my $domain =  mySociety::Config::get('EMAIL_DOMAIN');
    my $envelope_sender = mySociety::HandleMail::verp_envelope_sender($recipient, $prefix, $domain);
    return $envelope_sender
}

=item sendmail RECIPIENT SUBJECT TEXT

Send an email to RECIPIENT with the given SUBJECT and TEXT. Subject and body
should be UTF-8 strings.

=cut
sub sendmail ($$$) {
    my ($to, $subject, $text) = @_;

    # Add a signature to the body.
    $weburl = mySociety::Config::get('WEBURL');
    $text .= <<EOF;
--
$weburl/
EOF

    # Quoted-printable encoding of the subject.
    if ($subject =~ /[\x00-\x1f\x80-\xff]/) {
        $subject =~ s/([\x00-\x20\x80-\xff])/sprintf('=%02x', ord($1))/ge;
        $subject = "=?UTF-8?Q?$subject?=";
    }

    # Create a VERP envelope sender
    my $sender = verp_envelope_sender($to);

    # Generate a message-ID.
    my $msgid = sprintf('<%08x%0xf@hassleme.co.uk>',
                        int(rand(0xffffffff)), int(rand(0xffffffff)));

    my $mail = mySociety::Email::construct_email({
        _unwrapped_body_ => $text,
        From => ['hassle@hassleme.co.uk', 'HassleBot'],
        Subject => $subject,
        To => $to,
        'Message-ID' => $msgid,
    });

    my $result = mySociety::EmailUtil::send_email($mail, $sender, $to);
    if ($result == mySociety::EmailUtil::EMAIL_SUCCESS) {

    } elsif ($result == mySociety::EmailUtil::EMAIL_SOFT_ERROR) {
        die "soft error delivering message by email to $to";
    } else {
        die "hard error delivering message by email to $to";
    }
}

=item token ID

Return a signed token for ID.

=cut
sub token ($) {
    my $i = shift;
    my $salt = int(rand(10000));
    $tok = "${i}X${salt}X" . substr(sha1_hex(secret() . ",$i,$salt"), 0, 12);
    return $tok;
}

=item check_token TOKEN

If TOKEN is a valid token generated by token, return the ID it encodes.

=cut
sub check_token ($) {
    my $token = shift;
    return undef if (!$token);
    my ($i, $salt, $hash) = split(/[,X]/, $token);
    return undef if ($hash ne substr(sha1_hex(secret() . ",$i,$salt"), 0, 12));
    return $i;
}

=item delete_recipient EMAIL

Mark any recipient records relating to EMAIL address as deleted

=cut
sub delete_recipient ($){
    my $email = shift;
    return undef if (!$email);
    dbh()->do('update recipient set deleted=true where email = ?',
                {}, $email);
    dbh()->commit();
}

=item active_hassles

Return a statement handle containing all the currently active hassles

=cut

sub active_hassles(){
    my $s = dbh()->prepare('
                    select hassle.id, what, frequency, whencreated,
                        count(recipient)
                    from hassle, recipient
                    where hassle.id = recipient.hassle_id
                        and recipient.confirmed
                        and not recipient.deleted
                    group by hassle.id, hassle.what, hassle.frequency,
                        hassle.whencreated
                    having count(recipient) > 0');

    $s->execute();
    return $s;
}

=item is_valid_email EMAIL

If EMAIL is a valid address, return undef; otherwise return a sentence
explaining what's wrong with it.

=cut
sub is_valid_email ($) {
    my $addr = shift;
    my $is_valid = mySociety::EmailUtil::is_valid_email($addr);

    if ($is_valid) {
        my $s = dbh()->prepare('select email from no_send_list');

        $s->execute();
        while (my ($no_send_address) = $s->fetchrow_array()) {
            if ($addr eq $no_send_address){
                return "Sorry, we're not able to send email to '$addr'";
            }
        }

        my ($domain) = ($addr =~ /@(.+)/);
        our $R;
        if (!$R) {
            $R = new Net::DNS::Resolver();
            $R->tcp_timeout(3); # small timeout since this blocks FCGI server
#            $R->udp_timeout(3);
                # XXX old Net::DNS::Resolver on sphinx is TCP only?
        }
        my $resp = $R->send($domain, 'MX');
        if(defined($resp) && $resp->header()->ancount() == 0 ){
            $resp = $R->send($domain, 'A');
        }
        if (!defined($resp)     # timeout, probably
            || $resp->header()->ancount() > 0) {
            return undef;
        } else {
            # Definite negative response.
            return "The domain '$domain' doesn't seem to exist, so we wouldn't be able to send email to '$addr'";
        }
    } else {
        return "The email address '$addr' doesn't seem to be valid (its format is wrong)";
    }
}


1;
